apply plugin: 'tinkerpatch-support'

def bakPath = file("${buildDir}/bakApk/")
def baseInfo = "app-1.0.0-1112-12-49-34"
def variantName = "debug"

// 每次编译之后，会将最新构建的apk拷贝到该目录下，用于打patch.apk
def oldApkPath = "${bakPath}/tinkerOldApk/${variantName}"

tinkerpatchSupport {

    /** 当disable tinker的时候需要添加multiDexKeepProguard和proguardFiles,
     这些配置文件本身由tinkerPatch的插件自动添加，当你disable后需要手动添加
     你可以copy本示例中的proguardRules.pro和tinkerMultidexKeep.pro,
     需要你手动修改'tinker.sample.android.app'本示例的包名为你自己的包名, com.xxx前缀的包名不用修改
     **/
    tinkerEnable = true

    /** 一键配置，建议使用 **/
    reflectApplication = true

    /**
     * 是否开启加固模式，只能在APK将要进行加固时使用，否则会patch失败。
     * 如果只在某个渠道使用了加固，可使用多flavors配置
     **/
    protectedApp = false

    /** 实验功能：补丁是否支持新增 Activity (新增Activity的exported属性必须为false) **/
    supportComponent = true

    /** 必填 **/
    appKey = "${TINKER_ID}"

    /** 注意: 若发布新的全量包, appVersion一定要更新 **/
    appVersion = "${rootProject.ext.versionName}"

    /** 每次基础构建生成的 apk 所在的路径 **/
    autoBackupApkPath = "${bakPath}"

    /** 打 patch 的时候，会从该路径读取基础apk进行比对 **/
    baseApkFile = "${oldApkPath}/${project.name}-${variantName}.apk"
    baseProguardMappingFile = "${oldApkPath}/${project.name}-${variantName}-mapping.txt"
    baseResourceRFile = "${oldApkPath}/${project.name}-${variantName}-R.txt"
}

tinkerPatch {
    ignoreWarning = false
    useSign = true
    dex {
        dexMode = "jar"
        pattern = ["classes*.dex"]
        loader = []
    }
    lib {
        pattern = ["lib/*/*.so"]
    }
    res {
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
        ignoreChange = []
        largeModSize = 100
    }
    packageConfig {
    }
    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
    }
    buildConfig {
        keepDexApply = false
    }
}

android.applicationVariants.all { variant ->
    def taskName = variant.name
    tasks.all {
        if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
            it.doLast {

                // 检测目标文件夹是否存在，不存在就创建
                def oldApkDir = file("${oldApkPath}")
                if (!oldApkDir.exists()) {
                    oldApkDir.mkdir()
                }

                def fromPath = file("${bakPath}")
                if (!fromPath.exists()) {
                    return
                }

                // 获取到最新的生成 apk
                def newestPath = null

                if (fromPath.isDirectory()) {
                    fromPath.listFiles().each { file ->
                        if (file.isDirectory() && file.name.contains("${project.name}-${rootProject.ext.versionName}")) {
                            newestPath = file
                            // 找到了最新的生成路径，将其拷贝到指定路径
                            newestPath.listFiles().first().listFiles().each { inner_file ->
                                copy {
                                    from inner_file
                                    into oldApkPath
                                }
                                logger.error(("tinkerpatch.gradle doing copy ${inner_file.name} to ${oldApkPath}"))
                            }
                            return
                        }
                    }
                }

            }
        }
    }
}